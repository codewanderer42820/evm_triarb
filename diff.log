diff --git a/constants.go b/constants/constants.go
similarity index 65%
rename from constants.go
rename to constants/constants.go
index 197cb42..5757387 100644
--- a/constants.go
+++ b/constants/constants.go
@@ -13,67 +13,66 @@
 // ⚠️ No runtime logic here — all values must be compile-time resolvable
 // ─────────────────────────────────────────────────────────────────────────────
 
-package main
+package constants
 
 // ───────────────────────────── Deduplication ──────────────────────────────
 
 const (
-	// ringBits defines the size of the deduplication ring buffer: 2^21 entries = 2,097,152 slots ≈ 64 MiB.
-	// This is designed to hold approximately 24 hours of logs for high-FPS chains, such as Solana-like EVM chains.
-	// The buffer is sized for 2x throughput and has 10× overcapacity for peak times.
-	// This constant ensures the deduplication system can handle increased log rates while maintaining high performance under load.
-	ringBits = 21 // Increased for 2x throughput, accommodating more logs per second (≈ 2M entries)
+	// RingBits defines the size of the deduplication ring buffer: 2^19 entries = 524,288 slots ≈ 16 MiB.
+	// This buffer size is designed to accommodate high-FPS chains like Solana with a reduced memory footprint, while still ensuring efficient log handling.
+	// The buffer size is sufficient for typical bursts in log processing while maintaining high performance and low latency under load.
+	RingBits = 19 // Adjusted for optimal memory usage and throughput, accommodating logs for high-FPS chains such as Solana (~500k entries)
 
-	// maxReorg defines the maximum reorganization depth allowed before events are evicted.
+	// MaxReorg defines the maximum reorganization depth allowed before events are evicted.
 	// This is set to 256 blocks (approximately 6 minutes at 1.45s block time), ensuring that we can handle minor chain reorganizations
 	// while maintaining responsiveness to recent changes in high-throughput chains.
 	// A higher maxReorg depth ensures that the system can handle deeper reorganizations typical of Solana-like chains.
-	maxReorg = 256 // Increased to handle deeper reorgs in high-throughput chains (≈ 6 minutes at 1.45s block time)
+	MaxReorg = 256 // Increased to handle deeper reorgs in high-throughput chains (≈ 6 minutes at 1.45s block time)
 )
 
 // ─────────────────────────── Memory Guardrails ─────────────────────────────
 
 const (
-	// heapSoftLimit triggers non-blocking GC (garbage collection) when exceeded.
+	// HeapSoftLimit triggers non-blocking GC (garbage collection) when exceeded.
 	// If the heap size exceeds 256 MiB, the system will attempt to perform garbage collection
 	// without blocking, ensuring efficient memory usage during high-throughput periods.
-	heapSoftLimit = 256 << 20 // 256 MiB
+	HeapSoftLimit = 256 << 20 // 256 MiB
 
-	// heapHardLimit triggers a panic if the heap size exceeds this limit (1 GiB), signaling a failure state.
+	// HeapHardLimit triggers a panic if the heap size exceeds this limit (1 GiB), signaling a failure state.
 	// This ensures that the system stops if there is a potential memory leak or excessive memory usage.
-	heapHardLimit = 1024 << 20 // 1 GiB
+	HeapHardLimit = 1024 << 20 // 1 GiB
 )
 
 // ───────────────────────── WebSocket Configuration ─────────────────────────
 
 const (
-	// wsDialAddr specifies the WebSocket endpoint used to connect to an Ethereum-compatible provider.
+	// WsDialAddr specifies the WebSocket endpoint used to connect to an Ethereum-compatible provider.
 	// This address should be updated to match the desired network (e.g., mainnet, testnet) and provider (e.g., Infura, Alchemy).
 	// The URL format is typically "<network>-mainnet.infura.io" or "<network>-mainnet.alchemyapi.io".
-	wsDialAddr = "mainnet.infura.io:443" // Update this URL to match your provider and network
+	WsDialAddr = "mainnet.infura.io:443" // Update this URL to match your provider and network
 
-	// wsPath defines the HTTP path used during the WebSocket connection upgrade handshake.
+	// WsPath defines the HTTP path used during the WebSocket connection upgrade handshake.
 	// This path is specific to the WebSocket API of the Ethereum provider. It may vary depending on the provider.
 	// For example, Infura uses "/ws/v3/<project_id>" as the WebSocket endpoint path.
-	wsPath = "/ws/v3/a2a3139d2ab24d59bed2dc3643664126" // Replace with your own provider's WebSocket path
+	WsPath = "/ws/v3/a2a3139d2ab24d59bed2dc3643664126" // Replace with your own provider's WebSocket path
 
-	// wsHost specifies the host used in the SNI (Server Name Indication) during the TLS handshake.
+	// WsHost specifies the host used in the SNI (Server Name Indication) during the TLS handshake.
 	// This ensures that the WebSocket client connects securely to the provider’s servers.
 	// Typically, this is the base URL of the WebSocket service, e.g., "mainnet.infura.io" or "mainnet.alchemyapi.io".
-	wsHost = "mainnet.infura.io" // Update to match the provider’s host (e.g., Alchemy, Infura, or your custom provider)
+	WsHost = "mainnet.infura.io" // Update to match the provider’s host (e.g., Alchemy, Infura, or your custom provider)
 )
 
 // ──────────────────────── WebSocket Framing Caps ──────────────────────────
 
 const (
-	// maxFrameSize sets the maximum size for a raw WebSocket frame payload.
+	// MaxFrameSize sets the maximum size for a raw WebSocket frame payload.
 	// 1 MiB chosen to accommodate larger topic or data blobs in logs without exceeding buffer limits.
 	// This accommodates higher-frequency chains like Solana-like EVM chains.
-	maxFrameSize = 1024 << 10 // 1 MiB
+	MaxFrameSize = 1024 << 10 // 1 MiB
 
-	// frameCap defines the number of WebSocket frames that can be retained for parsing.
+	// FrameCap defines the number of WebSocket frames that can be retained for parsing.
 	// 524,288 frames for higher throughput scenarios, ensuring we can process more frames without exceeding buffer capacities.
-	frameCap = 1 << 19 // 524,288 frames (for 4k FPS or higher)
+	FrameCap = 1 << 19 // 524,288 frames (for 4k FPS or higher)
 )
 
 // ────────────────────── JSON Key Probes for Parsing ───────────────────────
@@ -84,37 +83,37 @@ var (
 	// They are 8-byte aligned to ensure efficient memory access and compatibility with low-level parsing techniques.
 	// Each probe must be ASCII-safe to ensure proper comparison without encoding issues.
 
-	// keyAddress is a probe for detecting the "address" field in JSON logs.
-	keyAddress = [8]byte{'"', 'a', 'd', 'd', 'r', 'e', 's', 's'} // "address" field in JSON logs
+	// KeyAddress is a probe for detecting the "address" field in JSON logs.
+	KeyAddress = [8]byte{'"', 'a', 'd', 'd', 'r', 'e', 's', 's'} // "address" field in JSON logs
 
-	// keyBlockHash is a probe for detecting the "blockHash" field in JSON logs.
-	keyBlockHash = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'H', 'a'} // "blockHash" field in JSON logs
+	// KeyBlockHash is a probe for detecting the "blockHash" field in JSON logs.
+	KeyBlockHash = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'H', 'a'} // "blockHash" field in JSON logs
 
-	// keyBlockNumber is a probe for detecting the "blockNumber" field in JSON logs.
-	keyBlockNumber = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'N', 'u'} // "blockNumber" field in JSON logs
+	// KeyBlockNumber is a probe for detecting the "blockNumber" field in JSON logs.
+	KeyBlockNumber = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'N', 'u'} // "blockNumber" field in JSON logs
 
-	// keyBlockTimestamp is a probe for detecting the "blockTimestamp" field in JSON logs.
-	keyBlockTimestamp = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'T', 'i'} // "blockTimestamp" field in JSON logs
+	// KeyBlockTimestamp is a probe for detecting the "blockTimestamp" field in JSON logs.
+	KeyBlockTimestamp = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'T', 'i'} // "blockTimestamp" field in JSON logs
 
-	// keyData is a probe for detecting the "data" field in JSON logs.
-	keyData = [8]byte{'"', 'd', 'a', 't', 'a', '"', ':', '"'} // "data" field in JSON logs
+	// KeyData is a probe for detecting the "data" field in JSON logs.
+	KeyData = [8]byte{'"', 'd', 'a', 't', 'a', '"', ':', '"'} // "data" field in JSON logs
 
-	// keyLogIndex is a probe for detecting the "logIndex" field in JSON logs.
-	keyLogIndex = [8]byte{'"', 'l', 'o', 'g', 'I', 'n', 'd', 'e'} // "logIndex" field in JSON logs
+	// KeyLogIndex is a probe for detecting the "logIndex" field in JSON logs.
+	KeyLogIndex = [8]byte{'"', 'l', 'o', 'g', 'I', 'n', 'd', 'e'} // "logIndex" field in JSON logs
 
-	// keyRemoved is a probe for detecting the "removed" field in JSON logs.
+	// KeyRemoved is a probe for detecting the "removed" field in JSON logs.
 	// The "removed" field indicates if the log was removed during reorganization.
-	keyRemoved = [8]byte{'"', 'r', 'e', 'm', 'o', 'v', 'e', 'd'} // "removed" field in JSON logs (indicates if the log was removed)
+	KeyRemoved = [8]byte{'"', 'r', 'e', 'm', 'o', 'v', 'e', 'd'} // "removed" field in JSON logs (indicates if the log was removed)
 
-	// keyTopics is a probe for detecting the "topics" field in JSON logs.
+	// KeyTopics is a probe for detecting the "topics" field in JSON logs.
 	// The "topics" field typically holds an array of topics associated with the log.
-	keyTopics = [8]byte{'"', 't', 'o', 'p', 'i', 'c', 's', '"'} // "topics" field in JSON logs (typically an array)
+	KeyTopics = [8]byte{'"', 't', 'o', 'p', 'i', 'c', 's', '"'} // "topics" field in JSON logs (typically an array)
 
-	// keyTransaction is a probe for detecting the "transactionHash" or "transactionIndex" field in JSON logs.
-	keyTransaction = [8]byte{'"', 't', 'r', 'a', 'n', 's', 'a', 'c'} // "transactionHash" or "transactionIndex" field in JSON logs
+	// KeyTransaction is a probe for detecting the "transactionHash" or "transactionIndex" field in JSON logs.
+	KeyTransaction = [8]byte{'"', 't', 'r', 'a', 'n', 's', 'a', 'c'} // "transactionHash" or "transactionIndex" field in JSON logs
 
-	// sigSyncPrefix is a constant signature used to identify Sync() events in the logs.
+	// SigSyncPrefix is a constant signature used to identify Sync() events in the logs.
 	// This 8-byte signature is checked for verifying the event type for Uniswap V2 Sync() logs.
 	// It is a fixed prefix that appears in the topics of these logs.
-	sigSyncPrefix = [8]byte{'1', 'c', '4', '1', '1', 'e', '9', 'a'} // Sync event signature in Uniswap V2 logs
+	SigSyncPrefix = [8]byte{'1', 'c', '4', '1', '1', 'e', '9', 'a'} // Sync event signature in Uniswap V2 logs
 )
diff --git a/dedupe.go b/dedupe/dedupe.go
similarity index 95%
rename from dedupe.go
rename to dedupe/dedupe.go
index 795a249..e4fa74e 100644
--- a/dedupe.go
+++ b/dedupe/dedupe.go
@@ -15,16 +15,19 @@
 //    and assumes exclusive access to each slot during event processing.
 // ─────────────────────────────────────────────────────────────────────────────
 
-package main
+package dedupe
 
-import "main/utils"
+import (
+	"main/constants"
+	"main/utils"
+)
 
 // Deduper is a lock-free circular buffer that tracks recent log identities.
 //
 //go:notinheap
 //go:align 64
 type Deduper struct {
-	buf [1 << ringBits]dedupeSlot // Deduplication ring buffer (power-of-two sized)
+	buf [1 << constants.RingBits]dedupeSlot // Deduplication ring buffer (power-of-two sized)
 }
 
 // dedupeSlot represents a single deduplication entry.
@@ -54,10 +57,10 @@ func (d *Deduper) Check(
 
 	// ───── 2. Efficiently access the deduplication slot using a single memory access ─────
 	// We apply a hash function to the key to locate the appropriate slot in the buffer.
-	slot := &d.buf[utils.Mix64(key)&((1<<ringBits)-1)]
+	slot := &d.buf[utils.Mix64(key)&((1<<constants.RingBits)-1)]
 
 	// ───── 3. Check for staleness based on three conditions: slot used, block progression, and reorg threshold ─────
-	stale := slot.age > 0 && latestBlk > slot.age && (latestBlk-slot.age) > maxReorg
+	stale := slot.age > 0 && latestBlk > slot.age && (latestBlk-slot.age) > constants.MaxReorg
 
 	// ───── 4. Branchless exact match using bitwise operations ─────
 	// Compare the current log event's identifiers against the stored ones using XOR.
diff --git a/main.go b/main.go
index 406d475..b5b3616 100644
--- a/main.go
+++ b/main.go
@@ -17,6 +17,7 @@ package main
 
 import (
 	"crypto/tls"
+	"main/constants"
 	"net"
 	"runtime"
 	"runtime/debug"
@@ -50,7 +51,7 @@ func main() {
 
 		// Read memory stats to monitor heap allocation and trigger garbage collection if needed.
 		runtime.ReadMemStats(&memstats)
-		if memstats.HeapAlloc > heapSoftLimit {
+		if memstats.HeapAlloc > constants.HeapSoftLimit {
 			// Trigger garbage collection if heap allocation exceeds the soft memory limit.
 			debug.SetGCPercent(100)             // Set GC to run at 100% for manual garbage collection.
 			runtime.GC()                        // Force garbage collection.
@@ -59,7 +60,7 @@ func main() {
 		}
 
 		// If memory allocation exceeds the hard limit, panic to indicate a potential memory leak.
-		if memstats.HeapAlloc > heapHardLimit {
+		if memstats.HeapAlloc > constants.HeapHardLimit {
 			panic("heap usage exceeded hard cap — leak likely detected")
 		}
 	}
@@ -72,7 +73,7 @@ func main() {
 func runPublisher() error {
 	// Step 1: Establish a raw TCP connection to the WebSocket server.
 	// This is the first step in setting up a WebSocket connection over TCP.
-	raw, err := net.Dial("tcp", wsDialAddr)
+	raw, err := net.Dial("tcp", constants.WsDialAddr)
 	if err != nil {
 		dropError("tcp dial", err)
 		return err
@@ -82,9 +83,9 @@ func runPublisher() error {
 	tcpConn := raw.(*net.TCPConn)
 
 	// Step 2: Configure TCP settings before obtaining the file descriptor.
-	tcpConn.SetNoDelay(true)             // Disable Nagle's algorithm for low-latency communication.
-	tcpConn.SetReadBuffer(maxFrameSize)  // Set read buffer size for the connection.
-	tcpConn.SetWriteBuffer(maxFrameSize) // Set write buffer size for the connection.
+	tcpConn.SetNoDelay(true)                       // Disable Nagle's algorithm for low-latency communication.
+	tcpConn.SetReadBuffer(constants.MaxFrameSize)  // Set read buffer size for the connection.
+	tcpConn.SetWriteBuffer(constants.MaxFrameSize) // Set write buffer size for the connection.
 
 	// Apply platform-specific optimizations to the socket for better performance.
 	if rawFile, err := tcpConn.File(); err == nil {
@@ -98,8 +99,8 @@ func runPublisher() error {
 	// Step 3: Wrap the raw TCP connection with TLS for secure WebSocket communication.
 	// TLS is used to encrypt the WebSocket traffic to ensure secure communication.
 	tlsConfig := &tls.Config{
-		ServerName:             wsHost, // Set ServerName for correct SNI (Server Name Indication) handling.
-		SessionTicketsDisabled: false,  // Enable session resumption for faster reconnections.
+		ServerName:             constants.WsHost, // Set ServerName for correct SNI (Server Name Indication) handling.
+		SessionTicketsDisabled: false,            // Enable session resumption for faster reconnections.
 	}
 	conn := tls.Client(raw, tlsConfig)  // Create a TLS connection.
 	defer func() { _ = conn.Close() }() // Ensure the TLS connection is closed when done.
@@ -171,8 +172,8 @@ func applySocketOptimizations(fd int) {
 		syscall.SetsockoptInt(fd, syscall.IPPROTO_TCP, 17, 1) // TCP_THIN_DUPACK = 17
 
 		// SO_RCVBUF and SO_SNDBUF - set to exact frame size for minimal buffering
-		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, maxFrameSize)
-		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, maxFrameSize)
+		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, constants.MaxFrameSize)
+		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, constants.MaxFrameSize)
 
 		// TCP_CONGESTION - use BBR if available, otherwise CUBIC
 		syscall.SetsockoptString(fd, syscall.IPPROTO_TCP, 13, "bbr") // TCP_CONGESTION = 13
@@ -200,8 +201,8 @@ func applySocketOptimizations(fd int) {
 		syscall.SetsockoptInt(fd, syscall.IPPROTO_TCP, 0x102, 3) // TCP_KEEPCNT equivalent
 
 		// SO_RCVBUF and SO_SNDBUF
-		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, maxFrameSize)
-		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, maxFrameSize)
+		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, constants.MaxFrameSize)
+		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, constants.MaxFrameSize)
 
 		// SO_REUSEADDR for faster port reuse
 		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)
@@ -220,8 +221,8 @@ func applySocketOptimizations(fd int) {
 		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, 1)
 
 		// Buffer sizes
-		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, maxFrameSize)
-		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, maxFrameSize)
+		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, constants.MaxFrameSize)
+		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, constants.MaxFrameSize)
 
 		// SO_REUSEADDR
 		syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)
diff --git a/parser.go b/parser.go
index 86fcf57..72ded84 100644
--- a/parser.go
+++ b/parser.go
@@ -17,13 +17,15 @@ package main
 
 import (
 	"fmt"
+	"main/constants"
+	"main/dedupe"
 	"main/types"
 	"main/utils"
 	"unsafe"
 )
 
 var (
-	deduper   Deduper
+	dedup     dedupe.Deduper
 	latestBlk uint32
 )
 
@@ -79,7 +81,7 @@ func handleFrame(p []byte) {
 
 		// Handle each tag by matching it to predefined keys and parsing accordingly
 		switch tag {
-		case keyAddress:
+		case constants.KeyAddress:
 			// Parse the Address field (assuming it follows the expected format)
 			start := i + utils.SkipToQuote(p[i:], 10, 1) + 1   // Start after the first quote
 			end := start + utils.SkipToQuote(p[start:], 0, 42) // The second quote marks the end
@@ -87,12 +89,12 @@ func handleFrame(p []byte) {
 			i = end + 1 // Update index after parsing the Address field
 			//missing &^= wantAddress // Mark Address as successfully parsed
 
-		case keyBlockHash:
+		case constants.KeyBlockHash:
 			// Skip over the block hash (80 bytes for a 0x-prefixed hex string)
 			i += 80
 			//missing &^= wantBlockHash
 
-		case keyBlockNumber:
+		case constants.KeyBlockNumber:
 			// Parse the Block Number field
 			start := i + utils.SkipToQuote(p[i:], 14, 1) + 1  // Start after the first quote
 			end := start + utils.SkipToQuote(p[start:], 0, 1) // The second quote marks the end
@@ -100,12 +102,12 @@ func handleFrame(p []byte) {
 			i = end + 1 // Update index after parsing the Block Number field
 			//missing &^= wantBlockNumber // Mark Block Number as successfully parsed
 
-		case keyBlockTimestamp:
+		case constants.KeyBlockTimestamp:
 			// Skip over the block timestamp (29 bytes for Infura's "blockTimestamp" field)
 			// This field is specific to Infura and doesn't require missing bitmask tracking.
 			i += 29
 
-		case keyData:
+		case constants.KeyData:
 			// Parse the Data field
 			start := i + utils.SkipToQuote(p[i:], 7, 1) + 1 // Start after the first quote
 			end, exit := utils.SkipToQuoteEarlyExit(p[start+2:], 0, 64, 3)
@@ -118,7 +120,7 @@ func handleFrame(p []byte) {
 			i = end + 1 // Update index after parsing the Data field
 			//missing &^= wantData // Mark Data as successfully parsed
 
-		case keyLogIndex:
+		case constants.KeyLogIndex:
 			// Parse the Log Index field
 			start := i + utils.SkipToQuote(p[i:], 11, 1) + 1  // Start after the first quote
 			end := start + utils.SkipToQuote(p[start:], 0, 1) // The second quote marks the end
@@ -126,12 +128,12 @@ func handleFrame(p []byte) {
 			i = end + 1 // Update index after parsing the Log Index field
 			//missing &^= wantLogIndex // Mark Log Index as successfully parsed
 
-		case keyRemoved:
+		case constants.KeyRemoved:
 			// Skip over the "removed":true field
 			i += 14 // "removed":true
 			//missing &^= wantRemoved
 
-		case keyTopics:
+		case constants.KeyTopics:
 			// Parse the Topics field (JSON array)
 			start := i + utils.SkipToOpeningBracket(p[i:], 9, 1) + 1 // Start after the opening bracket
 			end, exit := utils.SkipToClosingBracketEarlyExit(p[start-1:], 0, 69, 2)
@@ -146,13 +148,13 @@ func handleFrame(p []byte) {
 			}
 			v.Topics = p[start:end]
 			// Early exit if the Sync() signature doesn't match
-			if len(v.Topics) < 11 || *(*[8]byte)(unsafe.Pointer(&v.Topics[3])) != sigSyncPrefix {
+			if len(v.Topics) < 11 || *(*[8]byte)(unsafe.Pointer(&v.Topics[3])) != constants.SigSyncPrefix {
 				return // Exit early if it doesn't match Sync()
 			}
 			i = end + 1 // Update index after parsing the Topics field
 			//missing &^= wantTopics // Mark Topics as successfully parsed
 
-		case keyTransaction:
+		case constants.KeyTransaction:
 			// Skip over 86 bytes of Transaction Hash (this is to bypass the transaction hash field)
 			if len(p)-i >= 86 {
 				i += 86
@@ -203,7 +205,7 @@ func handleFrame(p []byte) {
 
 	// ───── Dedupe + Emit ─────
 	// Check if the event is a duplicate based on the parsed fields and deduper logic
-	if deduper.Check(blk32, tx32, log32, v.TagHi, v.TagLo, latestBlk) {
+	if dedup.Check(blk32, tx32, log32, v.TagHi, v.TagLo, latestBlk) {
 		// If the log is not a duplicate, emit it
 		emitLog(&v)
 	}
