diff --git a/.DS_Store b/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/.DS_Store and /dev/null differ
diff --git a/QuantumQueue/.DS_Store b/QuantumQueue/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/QuantumQueue/.DS_Store and /dev/null differ
diff --git a/constants.go b/constants.go
index 2b2595c..197cb42 100644
--- a/constants.go
+++ b/constants.go
@@ -93,6 +93,9 @@ var (
 	// keyBlockNumber is a probe for detecting the "blockNumber" field in JSON logs.
 	keyBlockNumber = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'N', 'u'} // "blockNumber" field in JSON logs
 
+	// keyBlockTimestamp is a probe for detecting the "blockTimestamp" field in JSON logs.
+	keyBlockTimestamp = [8]byte{'"', 'b', 'l', 'o', 'c', 'k', 'T', 'i'} // "blockTimestamp" field in JSON logs
+
 	// keyData is a probe for detecting the "data" field in JSON logs.
 	keyData = [8]byte{'"', 'd', 'a', 't', 'a', '"', ':', '"'} // "data" field in JSON logs
 
diff --git a/main_darwin.go b/main_darwin.go
index 919e475..9ff19a5 100644
--- a/main_darwin.go
+++ b/main_darwin.go
@@ -70,7 +70,11 @@ func runPublisher() error {
 		dropError("tcp dial", err)
 		return err
 	}
-	conn := tls.Client(raw, &tls.Config{ServerName: wsHost})
+	tlsConfig := &tls.Config{
+		ServerName:             wsHost, // Ensure the ServerName is set for proper SNI handling
+		SessionTicketsDisabled: false,  // Enable session resumption
+	}
+	conn := tls.Client(raw, tlsConfig)
 	defer func() { _ = conn.Close(); _ = raw.Close() }() // Ensure connections are closed after use
 
 	// ───── Step 2: Perform WebSocket Upgrade ─────
diff --git a/main_linux.go b/main_linux.go
index c137331..f8e27c4 100644
--- a/main_linux.go
+++ b/main_linux.go
@@ -70,7 +70,11 @@ func runPublisher() error {
 		dropError("tcp dial", err)
 		return err
 	}
-	conn := tls.Client(raw, &tls.Config{ServerName: wsHost})
+	tlsConfig := &tls.Config{
+		ServerName:             wsHost, // Ensure the ServerName is set for proper SNI handling
+		SessionTicketsDisabled: false,  // Enable session resumption
+	}
+	conn := tls.Client(raw, tlsConfig)
 	defer func() { _ = conn.Close(); _ = raw.Close() }() // Ensure proper closure of connections
 
 	// ───── Step 2: Perform WebSocket Upgrade ─────
diff --git a/parser.go b/parser.go
index a0aa8e1..f044cdb 100644
--- a/parser.go
+++ b/parser.go
@@ -74,52 +74,57 @@ func handleFrame(p []byte) {
 		tag := *(*[8]byte)(unsafe.Pointer(&p[i]))
 
 		// Handle each tag by matching it to predefined keys and parsing accordingly
-		switch {
-		case tag == keyAddress:
+		switch tag {
+		case keyAddress:
 			// Parse the Address field (assuming it follows the expected format)
-			start := i + utils.SkipToQuote(p[i:], 9, 1) + 1    // Start after the first quote
+			start := i + utils.SkipToQuote(p[i:], 10, 1) + 1   // Start after the first quote
 			end := start + utils.SkipToQuote(p[start:], 0, 42) // The second quote marks the end
 			v.Addr = p[start:end]
 			i = end + 1             // Update index after parsing the Address field
 			missing &^= wantAddress // Mark Address as successfully parsed
 
-		case tag == keyBlockHash:
+		case keyBlockHash:
 			// Skip over the block hash (80 bytes for a 0x-prefixed hex string)
 			i += 80
 			missing &^= wantBlockHash
 
-		case tag == keyBlockNumber:
+		case keyBlockNumber:
 			// Parse the Block Number field
-			start := i + utils.SkipToQuote(p[i:], 13, 1) + 1  // Start after the first quote
+			start := i + utils.SkipToQuote(p[i:], 14, 1) + 1  // Start after the first quote
 			end := start + utils.SkipToQuote(p[start:], 0, 1) // The second quote marks the end
 			v.BlkNum = p[start:end]
 			i = end + 1                 // Update index after parsing the Block Number field
 			missing &^= wantBlockNumber // Mark Block Number as successfully parsed
 
-		case tag == keyData:
+		case keyBlockTimestamp:
+			// Skip over the block timestamp (29 bytes for Infura's "blockTimestamp" field)
+			// This field is specific to Infura and doesn't require missing bitmask tracking.
+			i += 29
+
+		case keyData:
 			// Parse the Data field
-			start := i + utils.SkipToQuote(p[i:], 6, 1) + 1          // Start after the first quote
+			start := i + utils.SkipToQuote(p[i:], 7, 1) + 1          // Start after the first quote
 			end := start + 2 + utils.SkipToQuote(p[start+2:], 0, 64) // The second quote marks the end
 			v.Data = p[start:end]
 			i = end + 1          // Update index after parsing the Data field
 			missing &^= wantData // Mark Data as successfully parsed
 
-		case tag == keyLogIndex:
+		case keyLogIndex:
 			// Parse the Log Index field
-			start := i + utils.SkipToQuote(p[i:], 10, 1) + 1  // Start after the first quote
+			start := i + utils.SkipToQuote(p[i:], 11, 1) + 1  // Start after the first quote
 			end := start + utils.SkipToQuote(p[start:], 0, 1) // The second quote marks the end
 			v.LogIdx = p[start:end]
 			i = end + 1              // Update index after parsing the Log Index field
 			missing &^= wantLogIndex // Mark Log Index as successfully parsed
 
-		case tag == keyRemoved:
+		case keyRemoved:
 			// Skip over the "removed":true field
 			i += 14 // "removed":true
 			missing &^= wantRemoved
 
-		case tag == keyTopics:
+		case keyTopics:
 			// Parse the Topics field (JSON array)
-			start := i + utils.SkipToOpeningBracket(p[i:], 8, 1) + 1          // Start after the opening bracket
+			start := i + utils.SkipToOpeningBracket(p[i:], 9, 1) + 1          // Start after the opening bracket
 			end := start - 1 + utils.SkipToClosingBracket(p[start-1:], 0, 69) // The closing bracket marks the end
 			// Ensure end is not less than start (self-correcting)
 			if end < start {
@@ -133,14 +138,14 @@ func handleFrame(p []byte) {
 			i = end + 1            // Update index after parsing the Topics field
 			missing &^= wantTopics // Mark Topics as successfully parsed
 
-		case tag == keyTransaction:
+		case keyTransaction:
 			// Skip over 86 bytes of Transaction Hash (this is to bypass the transaction hash field)
 			if len(p)-i >= 86 {
 				i += 86
 				continue
 			}
 			// Parse the Transaction Index field
-			start := i + utils.SkipToQuote(p[i:], 18, 1) + 1  // Start after the first quote
+			start := i + utils.SkipToQuote(p[i:], 19, 1) + 1  // Start after the first quote
 			end := start + utils.SkipToQuote(p[start:], 0, 1) // The second quote marks the end
 			v.TxIndex = p[start:end]
 			i = end + 1                 // Update index after parsing the Transaction Index field
diff --git a/ring24/.DS_Store b/ring24/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/ring24/.DS_Store and /dev/null differ
diff --git a/router/.DS_Store b/router/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/router/.DS_Store and /dev/null differ
diff --git a/ws_io.go b/ws_io.go
index bfa9eca..c5a318a 100644
--- a/ws_io.go
+++ b/ws_io.go
@@ -94,6 +94,11 @@ func ensureRoom(conn net.Conn, need int) error {
 
 // ───────────────────────────── Frame Decoder ──────────────────────────────
 
+// This global slice holds the pre-allocated Ping frame. It ensures that there
+// is no allocation during runtime when sending the Ping frame.
+
+var pingFrame = []byte{0x89, 0x00} // Ping frame (FIN=1, Opcode=0x9)
+
 // readFrame parses a single complete WebSocket frame from the stream.
 //
 // This function decodes a WebSocket frame by processing its header, payload length, and mask, if present.
@@ -116,13 +121,23 @@ func readFrame(conn net.Conn) (*wsFrame, error) {
 		masked := hdr1 & 0x80
 		plen7 := int(hdr1 & 0x7F)
 
-		// Step 2: Handle control frames (skip)
+		// Step 2: Handle special control frames: Ping and Pong
 		switch opcode {
-		case 0x8:
-			// CLOSE frame, return EOF to signal closure
+		case 0x8: // CLOSE frame
+			// Return EOF to signal closure
 			return nil, io.EOF
-		case 0x9, 0xA:
-			// PING/PONG frames, just move the pointer and continue
+		case 0x9: // PING frame (opcode 0x9)
+			// Handle Ping frame by responding with Pong
+			wsStart += 2
+			wsLen -= 2
+			// Inline sendPing: No allocation, use pre-allocated slice
+			_, err := conn.Write(pingFrame) // Directly use pre-allocated pingFrame
+			if err != nil {
+				return nil, fmt.Errorf("sendPing failed: %v", err)
+			}
+			continue
+		case 0xA: // PONG frame (opcode 0xA)
+			// Just skip the Pong frame and continue to the next frame
 			wsStart += 2
 			wsLen -= 2
 			continue
